import { SignatureFileI, SignatureFileJSON } from "./SignatureFile";
import SignatureStatus from "../../types/responses/SignatureStatus";
import GetSignerResponse from "../../types/responses/GetSignerResponse";
export interface SignerI {
    /**
     * Signer name.
     */
    readonly name: string;
    /**
     * Signer email.
     */
    readonly email: string;
    /**
     * Signer optional parameters.
     */
    readonly params: SignerParams;
    /**
     * Associated signature files.
     */
    readonly files: Array<SignatureFileI>;
    /**
     * Token of this signer. It is filled by the system on
     * process a signature process.
     */
    token_signer: string;
    /**
     * Token of this signer. It is filled by the system on
     * process a signature process.
     */
    token_requester: string;
    /**
     * Adds a file to the signer. If exists, throws an error.
     * @param file - File to add.
     */
    addFile: (file: SignatureFileI) => void;
    /**
     * Deletes a file previously added. If not exist does not do anything.
     * @param file - File to add.
     */
    deleteFile: (file: SignatureFileI) => void;
    /**
     * Updates signer status and fires 'update.status' event.
     */
    updateStatus: (status: SignatureStatus) => Promise<void>;
    /**
     * Updates signer phone and fires 'update.phone' event.
     */
    updatePhone: (phone: string) => Promise<void>;
    /**
     * Updates signer email and fires 'update.email' event.
     */
    updateEmail: (email: string) => Promise<void>;
    /**
     * Adds an event that fires on specific event type.
     */
    addEventListener: <T extends keyof ListenerEventMap>(eventType: T, listener: ListenerEventMap[T]) => void;
    /**
     * Removes an event that fires on specific event type.
     */
    removeEventListener: <T extends keyof ListenerEventMap>(eventType: T, listener: ListenerEventMap[T]) => void;
    /**
     * Creates a JSON response to append as a body in a HTTP request.
     */
    toJSON: () => SignerJSON;
}
export default class Signer implements SignerI {
    readonly name: string;
    readonly params: SignerParams;
    readonly files: Array<SignatureFileI>;
    token_signer: string;
    token_requester: string;
    private _email;
    private events;
    constructor(name: string, email: string, params?: SignerParams);
    get email(): string;
    addFile(file: SignatureFileI): void;
    deleteFile(file: SignatureFileI): void;
    updateStatus(status: SignatureStatus): Promise<void>;
    updatePhone(phone: string): Promise<void>;
    updateEmail(email: string): Promise<void>;
    addEventListener<T extends keyof ListenerEventMap>(eventType: T, listener: ListenerEventMap[T]): void;
    removeEventListener<T extends keyof ListenerEventMap>(eventType: T, listener: ListenerEventMap[T]): void;
    private fireEvent;
    toJSON(): SignerJSON;
    static from(signerJSON: GetSignerResponse): Signer;
}
export declare type SignerParams = {
    phone?: string;
    /**
    * Type of Signer:
    * signer: Person who has to sign the document.
    * validator: Person who accepts or rejects the document.
    * witness: Person who can access and see the document.
    */
    type?: 'signer' | 'validator' | 'witness';
    /**
     * Number to filter in the GET /signer resource.
     */
    custom_int?: number;
    /**
     * String to filter in the GET /signer resource.
     */
    custom_string?: string;
    /**
     * Defines a code to view the document.
     */
    access_code?: string;
    /**
     * Accepted signature types.
     */
    force_signature_type?: 'all' | 'text' | 'sign' | 'image';
};
export interface SignerJSON {
    /**
     * Signer full name.
     */
    name: string;
    /**
     * Signer email.
     */
    email: string;
    phone?: string;
    /**
     * Type of Signer:
     * signer: Person who has to sign the document.
     * validator: Person who accepts or rejects the document.
     * witness: Person who can access and see the document.
     */
    type?: 'signer' | 'validator' | 'witness';
    /**
     * Number to filter in the GET /signer resource.
     */
    custom_int?: number;
    /**
     * String to filter in the GET /signer resource.
     */
    custom_string?: string;
    /**
     * Defines a code to view the document.
     */
    access_code?: string;
    /**
     * Accepted signature types.
     */
    force_signature_type?: 'all' | 'text' | 'sign' | 'image';
    /**
     * Associated PDF files.
     */
    files?: Array<SignatureFileJSON> | null;
}
interface ListenerEventMap {
    'update.phone': UpdateStringEvent;
    'update.email': UpdateStringEvent;
    'update.status': UpdateStatusEvent;
}
declare type UpdateStringEvent = (signer: SignerI, field: string) => Promise<any>;
declare type UpdateStatusEvent = (signer: SignerI, status: SignatureStatus) => Promise<any>;
export {};
