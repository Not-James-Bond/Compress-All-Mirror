import Task from "../Task";
import ILovePDFTool from "../../types/ILovePDFTool";
import { TaskParams } from '../Task';
import Auth from "../../auth/Auth";
import XHRInterface from "../../utils/XHRInterface";
import Requester from "./Requester";
import { SignerI } from "./Signer";
import TaskI, { ResponsesI, StatusI } from "../TaskI";
import SignatureFile from "./SignatureFile";
import SignatureProcessResponse from "../../types/responses/SignatureProcessResponse";
import SignatureStatus from "../../types/responses/SignatureStatus";
export interface SignProcessParams {
    /**
     * Emails language that will be received by signers.
     */
    language?: 'EN' | 'ES' | 'FR' | 'IT' | 'JA' | 'ZH-CN' | 'ZH-TW' | 'BG';
    /**
     * If true, allow signers to sign in parallel. Otherwise, do it sequentially.
     */
    lock_order?: boolean;
    /**
     * Days until the signature request will expire.
     */
    expiration_date?: number;
    /**
     * If true, a signed certified hash and a qualified timestamp is embedded to
     * the signed documents, ensuring document and signatures integrity in the
     * future. Certified signatures are eIDAS, ESIGN & UETA compliant.
     */
    certified?: boolean;
    /**
     * Requester number to facilitate filtering.
     */
    custom_int?: number;
    /**
     * Requester string to facilitate filtering.
     */
    custom_string?: string;
    /**
     * single: The signer is only one and no requests will be sent.
     * multiple: A signature request will be sent to the signers by a requester.
     *           All signers sign the same document.
     * batch: A signature request will be sent to the signers by a requester.
     *        Every signer sign the document separately.
     */
    mode?: 'single' | 'multiple' | 'batch';
    /**
     * REQUIRED if 'batch' mode is enabled.
     * Each file that needs to be signed by each signer.
     */
    batch_elements?: Array<SignatureFile>;
    /**
     * If true, displays UUID at the bottom of the signature. Otherwise, it is hidden.
     * This has only aesthetic purposes.
     */
    uuid_visible?: boolean;
    /**
     * Enables signature reminders.
     */
    reminders?: boolean;
    /**
     * If 'reminders' is true, reminders cycle can be set.
     * 1 <= signer_reminder_days_cycle <= expiration_days.
     */
    signer_reminder_days_cycle?: number;
}
export interface SignTemplateParams extends SignProcessParams {
    template_name: string;
}
interface Responses extends ResponsesI {
    process: Array<SignatureProcessResponse> | null;
}
interface Status extends StatusI {
    document: SignatureStatus;
    signers: {
        [email: string]: {
            email_status: number;
            phone_status: number;
        };
    };
}
interface SignTaskParams extends TaskParams {
    requester?: Requester;
    signers?: Array<SignerI>;
}
export default class SignTask extends Task {
    type: ILovePDFTool;
    requester: Requester | null;
    readonly signers: Array<SignerI>;
    readonly responses: Responses;
    constructor(auth: Auth, xhr: XHRInterface, params?: SignTaskParams);
    /**
     * @inheritdoc
     */
    getStatus(): Promise<Status>;
    /**
     * Saves the current task as template.
     * @param params - Template params.
     */
    saveAsTemplate(params: SignTemplateParams): Promise<TaskI>;
    processFromTemplate(template: TemplateElement): Promise<TaskI>;
    process(params?: SignProcessParams): Promise<TaskI>;
    /**
     * Creates a signature object as string to send to server.
     * @param params - Params to create a custom signature.
     */
    private createSignatureData;
    private fillSignerTokens;
    private processWithData;
    addSigner(signer: SignerI): void;
    deleteSigner(signer: SignerI): void;
    private addSignerListeners;
    private removeSignerListeners;
    private updateSignerPhone;
    private updateSignerEmail;
    private updateSignerStatus;
    private updateSignerField;
}
export interface TemplateElement extends SignatureProcessResponse {
    /**
     * Template name.
     */
    template_name: string;
}
export {};
