"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var StartError_1 = __importDefault(require("../errors/StartError"));
var globals_json_1 = __importDefault(require("../constants/globals.json"));
var DeleteError_1 = __importDefault(require("../errors/DeleteError"));
var UpdateError_1 = __importDefault(require("../errors/UpdateError"));
var DownloadError_1 = __importDefault(require("../errors/DownloadError"));
var ConnectError_1 = __importDefault(require("../errors/ConnectError"));
var TaskFactory_1 = __importDefault(require("./TaskFactory"));
var BaseFile_1 = __importDefault(require("./BaseFile"));
var PathError_1 = __importDefault(require("../errors/PathError"));
var FileNotExistsError_1 = __importDefault(require("../errors/FileNotExistsError"));
var FileAlreadyExistsError_1 = __importDefault(require("../errors/FileAlreadyExistsError"));
var typecheck_1 = require("../utils/typecheck");
var Task = /** @class */ (function () {
    /**
     *
     * @param publicKey - API public key.
     * @param secretKey - API private key.
     * @param makeStart - If true, start is called on instantiate a Task.
     */
    function Task(auth, xhr, params) {
        if (params === void 0) { params = {}; }
        this.auth = auth;
        this.xhr = xhr;
        var id = params.id, server = params.server, files = params.files;
        this._id = !!id ? id : '';
        this.server = !!server ? server : '';
        if (!!files) {
            this.files = files;
        }
        else {
            this.files = [];
        }
        this.responses = {
            start: null,
            addFile: null,
            deleteFile: null,
            process: null,
            download: null,
            delete: null,
            connect: null
        };
    }
    Object.defineProperty(Task.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    Task.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.xhr.get(globals_json_1.default.API_URL_PROTOCOL + "://" + globals_json_1.default.API_URL + "/" + globals_json_1.default.API_VERSION + "/start/" + this.type, {
                                headers: [
                                    ['Content-Type', 'application/json;charset=UTF-8'],
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                var task = data.task, server = data.server;
                                if (typecheck_1.thereIsUndefined([server, task])) {
                                    throw new StartError_1.default('Task cannot be started');
                                }
                                _this.server = server;
                                _this._id = _this._id ? _this._id : task;
                                // Keep response.
                                _this.responses.start = data;
                                return _this;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    Task.prototype.addFile = function (file) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (file instanceof BaseFile_1.default) {
                    return [2 /*return*/, this.uploadFromFile(file)];
                }
                return [2 /*return*/, this.uploadFromUrl(file)];
            });
        });
    };
    Task.prototype.uploadFromUrl = function (fileUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.xhr.post(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/upload", JSON.stringify({
                                task: this.id,
                                cloud_file: fileUrl
                            }), {
                                headers: [
                                    ['Content-Type', 'application/json;charset=UTF-8'],
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                var server_filename = data.server_filename;
                                if (typecheck_1.thereIsUndefined([server_filename]))
                                    throw new UpdateError_1.default('File cannot be uploaded');
                                var file = new BaseFile_1.default(_this.id, server_filename, _this.getBasename(fileUrl));
                                _this.files.push(file);
                                // Keep response.
                                _this.responses.addFile = data;
                                return _this;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    Task.prototype.getBasename = function (path) {
        var firstIndex = path.lastIndexOf('/') + 1;
        if (firstIndex === -1)
            throw new PathError_1.default('Path is malformed');
        var basename = path.substring(firstIndex);
        return basename;
    };
    Task.prototype.uploadFromFile = function (file) {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.files.indexOf(file) !== -1) {
                            throw new FileAlreadyExistsError_1.default();
                        }
                        return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        // Populate file with control data.
                        file.taskId = this.id;
                        return [2 /*return*/, this.xhr.post(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/upload", file, {
                                headers: [
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                var server_filename = data.server_filename;
                                if (typecheck_1.thereIsUndefined([server_filename]))
                                    throw new UpdateError_1.default('File cannot be uploaded');
                                // Populate file with control data.
                                file.serverFilename = server_filename;
                                // Insert inside the array of included files.
                                _this.files.push(file);
                                return _this;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    Task.prototype.deleteFile = function (file) {
        return __awaiter(this, void 0, void 0, function () {
            var token, index, fileToRemove;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        index = this.files.indexOf(file);
                        if (index === -1)
                            throw new FileNotExistsError_1.default();
                        fileToRemove = this.files[index];
                        return [2 /*return*/, this.xhr.delete(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/upload/" + this.id + "/" + fileToRemove.serverFilename, {
                                headers: [
                                    ['Content-Type', 'application/json;charset=UTF-8'],
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                // Remove file locally.
                                // Be careful with parallelism problems, it is needed a
                                // new search to remove the file.
                                var index = _this.files.indexOf(file);
                                _this.files.splice(index, 1);
                                // Keep response.
                                _this.responses.deleteFile = data;
                                return _this;
                            })];
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    Task.prototype.getFiles = function () {
        return this.files;
    };
    Task.prototype.getFilesBodyFormat = function () {
        var files = this.files.map(function (file) {
            return {
                server_filename: file.serverFilename,
                filename: file.filename,
                rotate: file.params.rotate,
                password: file.params.password
            };
        });
        return files;
    };
    /**
     * @inheritdoc
     */
    Task.prototype.download = function () {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.xhr.get(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/download/" + this.id, {
                                headers: [
                                    ['Authorization', "Bearer " + token]
                                ],
                                binary: true
                            })
                                .then(function (data) {
                                // Be careful with this negation. It depends on server response:
                                // Error if data === undefined || data === '' || data === null || data === false.
                                if (!data)
                                    throw new DownloadError_1.default('File cannot be downloaded');
                                // Keep response.
                                _this.responses.download = data;
                                return data;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    Task.prototype.delete = function () {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.xhr.delete(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/task/" + this.id, {
                                headers: [
                                    ['Content-Type', 'application/json;charset=UTF-8'],
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                var download_filename = data.download_filename, file_number = data.file_number, filesize = data.filesize, output_extensions = data.output_extensions, output_filesize = data.output_filesize, output_filenumber = data.output_filenumber, process_start = data.process_start, server = data.server, status = data.status, status_message = data.status_message, task = data.task, timer = data.timer, tool = data.tool;
                                if (typecheck_1.thereIsUndefined([download_filename, filesize,
                                    output_extensions, output_filenumber, output_filesize,
                                    status, timer, file_number, process_start, server,
                                    status_message, task, tool])) {
                                    throw new DeleteError_1.default('Task cannot be deleted');
                                }
                                // Keep response.
                                _this.responses.delete = data;
                                return _this;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    /**
     * @inheritdoc
     */
    Task.prototype.connect = function (nextTool) {
        return __awaiter(this, void 0, void 0, function () {
            var token;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.auth.getToken()];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.xhr.post(globals_json_1.default.API_URL_PROTOCOL + "://" + this.server + "/" + globals_json_1.default.API_VERSION + "/task/next", JSON.stringify({
                                task: this.id,
                                tool: nextTool
                            }), {
                                headers: [
                                    ['Content-Type', 'application/json;charset=UTF-8'],
                                    ['Authorization', "Bearer " + token]
                                ],
                                transformResponse: function (res) { return JSON.parse(res); }
                            })
                                .then(function (data) {
                                var task = data.task, files = data.files;
                                if (typecheck_1.thereIsUndefined([task, files])) {
                                    throw new ConnectError_1.default('Task cannot be connected');
                                }
                                var newTaskFiles = Object.entries(files).map(function (_a) {
                                    var server_filename = _a[0], filename = _a[1];
                                    return new BaseFile_1.default(_this.id, server_filename, filename);
                                });
                                // Keep response.
                                _this.responses.connect = data;
                                var taskFactory = new TaskFactory_1.default();
                                // Create the next new task and populate its attrs with response data.
                                // The server is the same than parent task.
                                var newTask = taskFactory.newTask(nextTool, _this.auth, _this.xhr, { id: task, server: _this.server, files: newTaskFiles });
                                return newTask;
                            })
                                .catch(function (e) {
                                throw e;
                            })];
                }
            });
        });
    };
    return Task;
}());
exports.default = Task;
//# sourceMappingURL=Task.js.map